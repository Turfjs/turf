diff --git a/dist/Core.js b/dist/Core.js
index f54c7a922c38d7eab2c6a6e1c8277c12f843b111..9eedff6ff2f016c5b5f7a34da132e45437167c20 100644
--- a/dist/Core.js
+++ b/dist/Core.js
@@ -6,6 +6,9 @@
 * Purpose   :  Core structures and functions for the Clipper Library           *
 * License   :  https://www.boost.org/LICENSE_1_0.txt                           *
 *******************************************************************************/
+
+import JSBI from "jsbi";
+
 // Note: all clipping operations except for Difference are commutative.
 export var ClipType;
 (function (ClipType) {
@@ -39,11 +42,11 @@ export var PointInPolygonResult;
 })(PointInPolygonResult || (PointInPolygonResult = {}));
 export var InternalClipper;
 (function (InternalClipper) {
-    InternalClipper.MaxInt64 = 9223372036854775807n;
-    InternalClipper.MaxCoord = Number(InternalClipper.MaxInt64 / 4n);
+    InternalClipper.MaxInt64 = JSBI.BigInt("9223372036854775807");
+    InternalClipper.MaxCoord = JSBI.toNumber(JSBI.divide(InternalClipper.MaxInt64, JSBI.BigInt(4)));
     InternalClipper.max_coord = InternalClipper.MaxCoord;
     InternalClipper.min_coord = -InternalClipper.MaxCoord;
-    InternalClipper.Invalid64 = Number(InternalClipper.MaxInt64);
+    InternalClipper.Invalid64 = JSBI.toNumber(InternalClipper.MaxInt64);
     InternalClipper.floatingPointTolerance = 1E-12;
     InternalClipper.defaultMinimumEdgeLength = 0.1;
     function crossProduct(pt1, pt2, pt3) {
@@ -77,15 +80,15 @@ export var InternalClipper;
         }
         if (signAB === 0)
             return 0; // both 0 because signs equal
-        const bigA = BigInt(a);
-        const bigB = BigInt(b);
-        const bigC = BigInt(c);
-        const bigD = BigInt(d);
-        const prod1 = bigA * bigB;
-        const prod2 = bigC * bigD;
-        if (prod1 === prod2)
+        const bigA = JSBI.BigInt(a);
+        const bigB = JSBI.BigInt(b);
+        const bigC = JSBI.BigInt(c);
+        const bigD = JSBI.BigInt(d);
+        const prod1 = JSBI.multiply(bigA, bigB);
+        const prod2 = JSBI.multiply(bigC, bigD);
+        if (JSBI.equal(prod1, prod2))
             return 0;
-        return (prod1 > prod2) ? 1 : -1;
+        return (JSBI.greaterThen(prod1, prod2)) ? 1 : -1;
     }
     InternalClipper.crossProductSign = crossProductSign;
     function checkPrecision(precision) {
@@ -104,13 +107,13 @@ export var InternalClipper;
     InternalClipper.triSign = triSign;
     function multiplyUInt64(a, b) {
         // Fix: a and b might be larger than 2^32, so don't use >>> 0
-        const aBig = BigInt(a);
-        const bBig = BigInt(b);
-        const res = aBig * bBig;
+        const aBig = JSBI.BigInt(a);
+        const bBig = JSBI.BigInt(b);
+        const res = JSBI.multiply(aBig, bBig);
         return {
-            lo64: Number(res & 0xffffffffffffffffn),
-            hi64: Number(res >> 64n)
-        };
+            lo64: JSBI.toNumber(JSBI.bitwiseAnd(res, JSBI.BigInt("0xffffffffffffffffn"))),
+            hi64: JSBI.toNumber(JSBI.signedRightShift(res, JSBI.BigInt(64))),
+        }
     }
     InternalClipper.multiplyUInt64 = multiplyUInt64;
     // returns true if (and only if) a * b == c * d
@@ -133,11 +136,11 @@ export var InternalClipper;
             return false;
         if (signAb === 0)
             return true;
-        const bigA = BigInt(absA);
-        const bigB = BigInt(absB);
-        const bigC = BigInt(absC);
-        const bigD = BigInt(absD);
-        return (bigA * bigB) === (bigC * bigD);
+        const bigA = JSBI.BigInt(absA);
+        const bigB = JSBI.BigInt(absB);
+        const bigC = JSBI.BigInt(absC);
+        const bigD = JSBI.BigInt(absD);
+        return JSBI.equal(JSBI.multiply(bigA, bigB), JSBI.multiply(bigC, bigD));
     }
     InternalClipper.productsAreEqual = productsAreEqual;
     function isCollinear(pt1, sharedPt, pt2) {